# EduGameHQ游戏数据自动化采集指南 v1.0

## 📋 项目概述

本文档详细说明如何为EduGameHQ平台自动化采集游戏数据，包括游戏信息、截图、元数据等，以提高数据录入效率并确保数据质量的一致性。

### 🎯 目标
- 自动化获取游戏基本信息（标题、描述、开发者等）
- 自动生成或下载高质量游戏截图
- 智能生成游戏标签和分类信息
- 批量处理大量游戏数据
- 避免文件冗余，优化存储结构

---

## 🔍 当前数据结构分析

### 现有数据库字段
基于 `doc/数据库字段设计文档.md` 的最新设计：

#### 🔵 核心字段（必需）
- `slug` - 游戏唯一标识符
- `title` - 游戏名称
- `category` - 游戏分类（系统标识）
- `categoryName` - 分类显示名称
- `url` - 游戏iframe地址
- `description` - 游戏描述

#### 🟢 显示字段（必需）
- `image` - 游戏截图/封面图片
- `imageFallback` - 备用图片格式
- `difficulty` - 游戏难易度
- `ageRange` - 适合年龄范围
- `minAge` - 最小适合年龄
- `maxAge` - 最大适合年龄
- `tags` - 游戏标签数组

#### 🟡 状态字段（可选）
- `playCount` - 游戏人气值
- `featured` - 是否特色游戏
- `trending` - 是否趋势游戏
- `isNew` - 是否新游戏

#### 🔴 开发者字段（必需）
- `developer` - 开发者名称
- `source` - 游戏来源平台
- `type` - 商业类型

---

## 🤖 自动化采集策略

### 字段获取难度分析

| 字段类型 | 自动化程度 | 获取方式 | 实现难度 |
|----------|------------|----------|----------|
| **✅ 完全自动** | 90%+ | 直接爬取 | 🟢 简单 |
| **⚠️ 半自动** | 50-90% | 爬取+AI辅助 | 🟡 中等 |
| **❌ 手动评估** | <50% | 人工判断 | 🔴 困难 |

#### ✅ 完全自动获取字段
```javascript
const autoFields = {
  title: "页面<title>标签或H1标签提取",
  url: "用户提供的iframe地址",
  slug: "根据title自动生成URL友好格式",
  source: "根据URL域名自动识别平台",
  developer: "页面开发者信息提取",
  type: "默认设为'Free'",
  playCount: "平台数据提取或随机生成"
};
```

#### ⚠️ 半自动获取字段
```javascript
const semiAutoFields = {
  description: "页面meta描述 + AI优化润色",
  image: "自动截图 + 官方图片下载",
  imageFallback: "自动生成JPG备用格式",
  tags: "基于分类的预设标签 + AI内容分析"
};
```

#### ❌ 手动评估字段
```javascript
const manualFields = {
  category: "需要理解游戏内容进行分类",
  categoryName: "基于category自动映射",
  difficulty: "需要试玩评估游戏难度",
  ageRange: "需要教育专业知识判断",
  minAge: "基于ageRange自动计算",
  maxAge: "基于ageRange自动计算",
  featured: "编辑策略决定",
  trending: "基于数据分析决定",
  isNew: "基于添加时间自动设置"
};
```

---

## 🖼️ 游戏截图自动化方案

### 方案1: 智能截图系统（推荐）

**技术栈**: Puppeteer + Sharp图片处理

**截图策略**:
1. **智能等待** - 等待游戏完全加载（5-8秒）
2. **交互模拟** - 自动点击开始按钮、跳过介绍
3. **多状态截图** - 加载页面、游戏界面、操作界面
4. **图片优化** - 统一尺寸、格式转换、质量压缩

```javascript
// 核心截图逻辑
async function captureGameScreenshot(gameUrl, gameSlug, category) {
  const page = await browser.newPage();
  
  // 设置视窗大小
  await page.setViewport({ width: 800, height: 600 });
  
  try {
    // 访问游戏页面
    await page.goto(gameUrl, { 
      waitUntil: 'networkidle0',
      timeout: 30000 
    });
    
    // 等待游戏加载
    await page.waitForTimeout(8000);
    
    // 尝试点击开始按钮
    const playButtons = [
      '.play-button', '.start-button', '.begin-button',
      '[class*="play"]', '[class*="start"]', 
      'button:contains("Play")', 'button:contains("Start")'
    ];
    
    for (const selector of playButtons) {
      try {
        await page.click(selector, { timeout: 2000 });
        await page.waitForTimeout(3000);
        console.log(`✅ 成功点击开始按钮: ${selector}`);
        break;
      } catch (e) {
        // 继续尝试下一个选择器
      }
    }
    
    // 尝试跳过介绍或教程
    const skipButtons = [
      '.skip-button', '.skip-intro', '.next-button',
      '[class*="skip"]', 'button:contains("Skip")'
    ];
    
    for (const selector of skipButtons) {
      try {
        await page.click(selector, { timeout: 1000 });
        await page.waitForTimeout(2000);
        break;
      } catch (e) {
        // 继续
      }
    }
    
    // 截图保存路径
    const imagePath = `public/images/games/${category}/${gameSlug}`;
    
    // 截图并保存为WebP格式
    await page.screenshot({
      path: `${imagePath}.webp`,
      type: 'webp',
      quality: 80,
      clip: { x: 0, y: 0, width: 800, height: 600 }
    });
    
    // 生成JPG备用格式
    await page.screenshot({
      path: `${imagePath}.jpg`,
      type: 'jpeg', 
      quality: 85,
      clip: { x: 0, y: 0, width: 800, height: 600 }
    });
    
    console.log(`📸 截图完成: ${gameSlug}`);
    
    return {
      image: `/images/games/${category}/${gameSlug}.webp`,
      imageFallback: `/images/games/${category}/${gameSlug}.jpg`
    };
    
  } catch (error) {
    console.error(`❌ 截图失败: ${gameSlug} - ${error.message}`);
    
    // 使用默认图片
    return {
      image: `/images/games/default.webp`,
      imageFallback: `/images/games/default.jpg`
    };
  } finally {
    await page.close();
  }
}
```

### 方案2: 官方图片下载

**优先级**: 如果游戏页面有官方截图，优先下载

```javascript
// 官方图片下载逻辑
async function downloadOfficialImage(gamePageUrl, gameSlug, category) {
  try {
    const response = await fetch(gamePageUrl);
    const html = await response.text();
    
    // 查找官方图片的多种可能位置
    const imageSelectors = [
      'meta[property="og:image"]',
      'meta[name="twitter:image"]',
      '.game-screenshot img',
      '.game-thumbnail img',
      '.game-preview img',
      '.game-image img',
      '.screenshot img'
    ];
    
    for (const selector of imageSelectors) {
      const imageUrl = extractImageFromHTML(html, selector);
      if (imageUrl && isValidImageUrl(imageUrl)) {
        const success = await downloadAndOptimizeImage(
          imageUrl, 
          gameSlug, 
          category
        );
        if (success) {
          console.log(`✅ 官方图片下载成功: ${gameSlug}`);
          return {
            image: `/images/games/${category}/${gameSlug}.webp`,
            imageFallback: `/images/games/${category}/${gameSlug}.jpg`
          };
        }
      }
    }
    
    console.log(`⚠️ 未找到官方图片: ${gameSlug}`);
    return null;
    
  } catch (error) {
    console.error(`❌ 官方图片下载失败: ${gameSlug} - ${error.message}`);
    return null;
  }
}

// 下载并优化图片
async function downloadAndOptimizeImage(imageUrl, gameSlug, category) {
  try {
    const response = await axios.get(imageUrl, {
      responseType: 'arraybuffer',
      timeout: 10000,
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
      }
    });
    
    const imageBuffer = Buffer.from(response.data);
    const imagePath = `public/images/games/${category}/${gameSlug}`;
    
    // 使用Sharp处理图片
    await sharp(imageBuffer)
      .resize(400, 300, { 
        fit: 'cover',
        position: 'center'
      })
      .webp({ quality: 80 })
      .toFile(`${imagePath}.webp`);
    
    await sharp(imageBuffer)
      .resize(400, 300, { 
        fit: 'cover',
        position: 'center'
      })
      .jpeg({ quality: 85 })
      .toFile(`${imagePath}.jpg`);
    
    return true;
  } catch (error) {
    console.error(`图片处理失败: ${error.message}`);
    return false;
  }
}
```

---

## 🛠️ 自动化工具架构

### 主要类设计

```javascript
class GameDataScraper {
  constructor() {
    this.browser = null;
    this.outputDir = './src/data';
    this.imageDir = './public/images/games';
    
    // 支持的游戏平台
    this.platforms = {
      'crazygames.com': this.scrapeCrazyGames.bind(this),
      'miniplay.com': this.scrapeMiniplay.bind(this),
      'gamedistribution.com': this.scrapeGameDistribution.bind(this),
      'scratch.mit.edu': this.scrapeScratch.bind(this)
    };
    
    // 分类映射
    this.categoryNames = {
      'math': 'Math',
      'science': 'Science',
      'coding': 'Programming',
      'language': 'Language Arts',
      'puzzle': 'Puzzle',
      'sports': 'Sports',
      'art': 'Art & Creativity',
      'geography': 'Geography & History'
    };
  }
  
  // 初始化浏览器和目录
  async init() {
    console.log('🚀 启动游戏数据采集工具...');
    
    this.browser = await puppeteer.launch({ 
      headless: false, // 可视化模式，便于调试
      defaultViewport: { width: 1200, height: 800 },
      args: ['--no-sandbox', '--disable-setuid-sandbox']
    });
    
    // 确保输出目录存在
    await this.ensureDirectories();
  }
  
  // 确保所有必要目录存在
  async ensureDirectories() {
    const dirs = [
      this.outputDir,
      this.imageDir,
      `${this.imageDir}/math`,
      `${this.imageDir}/science`,
      `${this.imageDir}/coding`,
      `${this.imageDir}/language`,
      `${this.imageDir}/puzzle`,
      `${this.imageDir}/sports`,
      `${this.imageDir}/art`,
      `${this.imageDir}/geography`
    ];

    for (const dir of dirs) {
      try {
        await fs.mkdir(dir, { recursive: true });
      } catch (error) {
        // 目录已存在，忽略错误
      }
    }
  }
  
  // 主要采集方法
  async scrapeGame(gameUrl, category = 'math') {
    console.log(`📥 开始采集游戏: ${gameUrl}`);
    
    try {
      // 识别游戏平台
      const platform = this.identifyPlatform(gameUrl);
      if (!platform) {
        throw new Error('不支持的游戏平台');
      }

      // 调用对应平台的采集函数
      const gameData = await this.platforms[platform](gameUrl, category);
      
      // 生成截图
      const imageData = await this.captureScreenshot(gameData);
      Object.assign(gameData, imageData);
      
      // AI辅助优化数据
      await this.enhanceWithAI(gameData);
      
      console.log(`✅ 游戏采集完成: ${gameData.title}`);
      return gameData;
      
    } catch (error) {
      console.error(`❌ 采集失败: ${error.message}`);
      throw error;
    }
  }
  
  // 识别游戏平台
  identifyPlatform(url) {
    for (const platform of Object.keys(this.platforms)) {
      if (url.includes(platform)) {
        return platform;
      }
    }
    return null;
  }
  
  // 构建完整的游戏数据对象
  buildGameData(scrapedData, gameUrl, category) {
    const slug = this.generateSlug(scrapedData.title);
    
    return {
      slug,
      title: scrapedData.title,
      category,
      categoryName: this.categoryNames[category] || 'Educational',
      url: gameUrl,
      description: scrapedData.description,
      difficulty: 'Medium', // 默认值，后续可手动调整
      ageRange: this.getDefaultAgeRange(category),
      minAge: this.getDefaultMinAge(category),
      maxAge: this.getDefaultMaxAge(category),
      image: '', // 将在截图后填充
      imageFallback: '', // 将在截图后填充
      playCount: scrapedData.playCount || Math.floor(Math.random() * 10000) + 1000,
      tags: this.generateTags(category, scrapedData.title),
      featured: false,
      trending: false,
      isNew: true,
      developer: scrapedData.developer,
      source: scrapedData.source,
      type: 'Free'
    };
  }
  
  // 生成URL友好的slug
  generateSlug(title) {
    return title
      .toLowerCase()
      .replace(/[^a-z0-9\s-]/g, '')
      .replace(/\s+/g, '-')
      .replace(/-+/g, '-')
      .trim('-');
  }
  
  // 根据分类获取默认年龄范围
  getDefaultAgeRange(category) {
    const ageRanges = {
      'math': '6-14',
      'science': '8-16',
      'coding': '10-18',
      'language': '6-16',
      'puzzle': '8-16',
      'sports': '6-18',
      'art': '6-16',
      'geography': '10-18'
    };
    return ageRanges[category] || '8-14';
  }
  
  // 根据分类获取默认最小年龄
  getDefaultMinAge(category) {
    const ageRange = this.getDefaultAgeRange(category);
    return parseInt(ageRange.split('-')[0]);
  }
  
  // 根据分类获取默认最大年龄
  getDefaultMaxAge(category) {
    const ageRange = this.getDefaultAgeRange(category);
    return parseInt(ageRange.split('-')[1]);
  }
  
  // 生成基础标签
  generateTags(category, title) {
    const baseTags = ['educational', 'free', 'online'];
    const categoryTags = {
      'math': ['math', 'numbers', 'calculation', 'arithmetic'],
      'science': ['science', 'experiment', 'discovery', 'STEM'],
      'coding': ['programming', 'coding', 'logic', 'computer'],
      'language': ['language', 'vocabulary', 'reading', 'writing'],
      'puzzle': ['puzzle', 'brain', 'logic', 'thinking'],
      'sports': ['sports', 'physical', 'competition', 'fitness'],
      'art': ['art', 'creativity', 'design', 'drawing'],
      'geography': ['geography', 'history', 'world', 'culture']
    };
    
    const tags = [...baseTags, ...(categoryTags[category] || [])];
    
    // 根据标题添加特定标签
    const titleLower = title.toLowerCase();
    if (titleLower.includes('2048')) tags.push('2048', 'merge');
    if (titleLower.includes('duck')) tags.push('animals', 'duck');
    if (titleLower.includes('typing')) tags.push('typing', 'keyboard');
    if (titleLower.includes('memory')) tags.push('memory', 'brain-training');
    
    return [...new Set(tags)]; // 去重
  }
  
  // 批量处理游戏列表
  async batchScrape(gameList) {
    console.log(`🔄 开始批量处理 ${gameList.length} 个游戏...`);
    
    const results = [];
    const errors = [];
    
    for (let i = 0; i < gameList.length; i++) {
      const { url, category, title } = gameList[i];
      console.log(`\n📥 处理第 ${i + 1}/${gameList.length} 个游戏: ${title || url}`);
      
      try {
        const gameData = await this.scrapeGame(url, category);
        results.push(gameData);
        
        // 保存单个游戏数据
        await this.saveGameData(gameData);
        
        // 避免请求过于频繁
        await this.delay(3000);
        
      } catch (error) {
        errors.push({ url, title, error: error.message });
        console.error(`❌ 处理失败: ${title || url}`);
      }
    }
    
    // 生成汇总报告
    await this.generateReport(results, errors);
    
    console.log(`\n✅ 批量处理完成!`);
    console.log(`成功: ${results.length} 个`);
    console.log(`失败: ${errors.length} 个`);
    
    return { results, errors };
  }
  
  // 保存游戏数据到JSON文件
  async saveGameData(gameData) {
    const filePath = `${this.outputDir}/games.json`;
    
    try {
      // 读取现有数据
      let existingData = [];
      try {
        const fileContent = await fs.readFile(filePath, 'utf8');
        existingData = JSON.parse(fileContent);
      } catch (e) {
        // 文件不存在，使用空数组
      }
      
      // 检查是否已存在
      const existingIndex = existingData.findIndex(game => game.slug === gameData.slug);
      
      if (existingIndex >= 0) {
        // 更新现有游戏
        existingData[existingIndex] = gameData;
        console.log(`🔄 更新游戏数据: ${gameData.title}`);
      } else {
        // 添加新游戏
        existingData.push(gameData);
        console.log(`➕ 添加新游戏: ${gameData.title}`);
      }
      
      // 保存文件
      await fs.writeFile(filePath, JSON.stringify(existingData, null, 2));
      
    } catch (error) {
      console.error(`❌ 保存游戏数据失败: ${error.message}`);
    }
  }
  
  // 延迟函数
  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
  
  // 清理资源
  async cleanup() {
    if (this.browser) {
      await this.browser.close();
    }
    console.log('🧹 资源清理完成');
  }
}
```

### 平台特定适配器

#### CrazyGames适配器
```javascript
async scrapeCrazyGames(gameUrl, category) {
  const page = await this.browser.newPage();
  await page.goto(gameUrl, { waitUntil: 'networkidle0' });
  
  const gameData = await page.evaluate(() => {
    // 获取游戏标题
    const title = document.querySelector('h1')?.textContent?.trim() || 
                 document.title.split(' - ')[0];
    
    // 获取游戏描述
    const description = document.querySelector('meta[name="description"]')?.content ||
                       document.querySelector('.game-description')?.textContent?.trim() ||
                       `Play ${title} online for free. Educational game perfect for learning.`;
    
    // 获取开发者信息
    const developer = document.querySelector('.developer-name')?.textContent?.trim() ||
                     document.querySelector('.game-author')?.textContent?.trim() ||
                     'CrazyGames';
    
    // 获取播放次数（如果有）
    const playCountText = document.querySelector('.play-count')?.textContent;
    let playCount = 0;
    if (playCountText) {
      const match = playCountText.match(/[\d,]+/);
      if (match) {
        playCount = parseInt(match[0].replace(/,/g, ''));
      }
    }
    
    return {
      title,
      description,
      developer,
      playCount,
      source: 'CrazyGames'
    };
  });
  
  await page.close();
  return this.buildGameData(gameData, gameUrl, category);
}
```

#### Miniplay适配器
```javascript
async scrapeMiniplay(gameUrl, category) {
  const page = await this.browser.newPage();
  await page.goto(gameUrl, { waitUntil: 'networkidle0' });
  
  const gameData = await page.evaluate(() => {
    const title = document.querySelector('.game-title')?.textContent?.trim() ||
                 document.querySelector('h1')?.textContent?.trim() ||
                 document.title.split(' - ')[0];
    
    const description = document.querySelector('.game-description')?.textContent?.trim() ||
                       document.querySelector('meta[name="description"]')?.content ||
                       `Play ${title} online. Fun educational game for kids.`;
    
    const developer = document.querySelector('.game-developer')?.textContent?.trim() ||
                     'Miniplay';
    
    return {
      title,
      description,
      developer,
      playCount: 0,
      source: 'Miniplay'
    };
  });
  
  await page.close();
  return this.buildGameData(gameData, gameUrl, category);
}
```

---

## 📁 文件清理和重组策略

### 当前问题分析
1. **文件冗余** - 存在大量SVG占位符和空的JPG文件
2. **结构混乱** - 图片文件没有按分类组织
3. **数据不一致** - 存在过时的字段和格式

### 清理步骤

#### 第一步: 数据备份
```bash
# 备份现有数据
cp src/data/games.json src/data/games-backup-$(date +%Y%m%d).json

# 备份图片目录
cp -r public/images/games public/images/games-backup-$(date +%Y%m%d)
```

#### 第二步: 清理无用文件
```bash
# 删除SVG占位符
find public/images/games/ -name "*.svg" -delete

# 删除小于1KB的空JPG文件
find public/images/games/ -name "*.jpg" -size -1k -delete

# 删除小于1KB的空WebP文件
find public/images/games/ -name "*.webp" -size -1k -delete
```

#### 第三步: 重组目录结构
```javascript
// 按分类重组图片文件
async function reorganizeImageFiles() {
  const gamesData = JSON.parse(await fs.readFile('src/data/games.json', 'utf8'));
  
  for (const game of gamesData) {
    const oldImagePath = `public/images/games/${game.slug}`;
    const newImagePath = `public/images/games/${game.category}/${game.slug}`;
    
    // 移动WebP文件
    if (await fileExists(`${oldImagePath}.webp`)) {
      await fs.rename(`${oldImagePath}.webp`, `${newImagePath}.webp`);
    }
    
    // 移动JPG文件
    if (await fileExists(`${oldImagePath}.jpg`)) {
      await fs.rename(`${oldImagePath}.jpg`, `${newImagePath}.jpg`);
    }
    
    // 更新游戏数据中的图片路径
    game.image = `/images/games/${game.category}/${game.slug}.webp`;
    game.imageFallback = `/images/games/${game.category}/${game.slug}.jpg`;
  }
  
  // 保存更新后的数据
  await fs.writeFile('src/data/games.json', JSON.stringify(gamesData, null, 2));
}
```

#### 第四步: 数据结构更新
```javascript
// 更新数据结构，移除旧字段，添加新字段
function updateGameDataStructure(gameData) {
  // 移除不需要的字段
  delete gameData.rating;
  delete gameData.learningObjectives;
  delete gameData.gameFeatures;
  
  // 添加年龄字段（如果不存在）
  if (!gameData.ageRange) {
    const defaultAges = {
      'math': { ageRange: '6-14', minAge: 6, maxAge: 14 },
      'science': { ageRange: '8-16', minAge: 8, maxAge: 16 },
      'coding': { ageRange: '10-18', minAge: 10, maxAge: 18 },
      'language': { ageRange: '6-16', minAge: 6, maxAge: 16 },
      'puzzle': { ageRange: '8-16', minAge: 8, maxAge: 16 },
      'sports': { ageRange: '6-18', minAge: 6, maxAge: 18 },
      'art': { ageRange: '6-16', minAge: 6, maxAge: 16 },
      'geography': { ageRange: '10-18', minAge: 10, maxAge: 18 }
    };
    
    const ages = defaultAges[gameData.category] || { ageRange: '8-14', minAge: 8, maxAge: 14 };
    Object.assign(gameData, ages);
  }
  
  // 确保必需字段存在
  if (!gameData.difficulty) gameData.difficulty = 'Medium';
  if (!gameData.type) gameData.type = 'Free';
  if (!gameData.tags) gameData.tags = ['educational', 'free', 'online'];
  
  return gameData;
}
```

---

## 🚀 实施计划

### 阶段1: 环境准备（半天）

#### 安装依赖
```bash
# 安装核心依赖
npm install puppeteer sharp axios cheerio

# 安装开发依赖
npm install --save-dev @types/node
```

#### 创建目录结构
```bash
# 创建脚本目录
mkdir -p scripts reports temp

# 创建分类图片目录
mkdir -p public/images/games/{math,science,coding,language,puzzle,sports,art,geography}
```

### 阶段2: 数据清理（半天）

1. **备份现有数据**
   ```bash
   npm run backup-data
   ```

2. **清理无用文件**
   ```bash
   npm run clean-files
   ```

3. **重构数据结构**
   ```bash
   npm run update-structure
   ```

### 阶段3: 工具开发（1-2天）

1. **开发主爬虫脚本** (`scripts/game-scraper.js`)
2. **开发平台适配器** (CrazyGames, Miniplay, GameDistribution, Scratch)
3. **开发截图功能** (Puppeteer自动截图)
4. **开发图片处理** (Sharp优化)
5. **开发批量处理** (支持游戏列表批量处理)

### 阶段4: 数据采集（1-2天）

1. **准备游戏列表** (基于现有games.json和新需求)
2. **分批采集数据** (每批20-30个游戏，避免过载)
3. **人工审核关键字段** (分类、难度、年龄范围)
4. **数据验证和修复** (确保所有字段完整有效)

---

## 📊 质量保证和验证

### 数据验证规则

```javascript
// 数据完整性验证
function validateGameData(gameData) {
  const errors = [];
  
  // 必需字段检查
  const requiredFields = [
    'slug', 'title', 'category', 'categoryName', 
    'url', 'description', 'image', 'imageFallback',
    'difficulty', 'ageRange', 'minAge', 'maxAge',
    'developer', 'source', 'type'
  ];
  
  for (const field of requiredFields) {
    if (!gameData[field]) {
      errors.push(`缺少必需字段: ${field}`);
    }
  }
  
  // 字段格式验证
  if (gameData.slug && !/^[a-z0-9-]+$/.test(gameData.slug)) {
    errors.push('slug格式不正确');
  }
  
  if (gameData.url && !isValidUrl(gameData.url)) {
    errors.push('URL格式不正确');
  }
  
  if (gameData.ageRange && !/^\d+-\d+$/.test(gameData.ageRange)) {
    errors.push('年龄范围格式不正确');
  }
  
  if (gameData.minAge && gameData.maxAge && gameData.minAge > gameData.maxAge) {
    errors.push('最小年龄不能大于最大年龄');
  }
  
  // 图片文件存在性检查
  if (gameData.image && !fileExists(`public${gameData.image}`)) {
    errors.push('主图片文件不存在');
  }
  
  if (gameData.imageFallback && !fileExists(`public${gameData.imageFallback}`)) {
    errors.push('备用图片文件不存在');
  }
  
  return errors;
}
```

### 图片质量标准

```javascript
// 图片质量检查
async function validateImageQuality(imagePath) {
  try {
    const metadata = await sharp(imagePath).metadata();
    
    const issues = [];
    
    // 尺寸检查
    if (metadata.width !== 400 || metadata.height !== 300) {
      issues.push(`尺寸不标准: ${metadata.width}x${metadata.height}, 应为400x300`);
    }
    
    // 文件大小检查
    const stats = await fs.stat(imagePath);
    if (stats.size > 100 * 1024) { // 100KB
      issues.push(`文件过大: ${Math.round(stats.size / 1024)}KB, 应小于100KB`);
    }
    
    // 格式检查
    if (!['webp', 'jpeg'].includes(metadata.format)) {
      issues.push(`格式不支持: ${metadata.format}, 应为webp或jpeg`);
    }
    
    return issues;
  } catch (error) {
    return [`图片读取失败: ${error.message}`];
  }
}
```

---

## 📈 预期效果和成果

### 自动化程度预期

| 任务类型 | 自动化比例 | 人工工作量 | 时间节省 |
|----------|------------|------------|----------|
| 基本信息获取 | 90% | 10% | 节省80%时间 |
| 图片获取处理 | 95% | 5% | 节省90%时间 |
| 数据验证清理 | 70% | 30% | 节省60%时间 |
| 整体数据录入 | 85% | 15% | 节省75%时间 |

### 最终交付成果

1. **完整的游戏数据库**
   - 符合最新数据库字段设计
   - 包含所有必需字段
   - 数据格式统一标准

2. **高质量游戏截图**
   - 统一400x300尺寸
   - WebP主格式 + JPG备用格式
   - 按分类组织存储

3. **清理的文件结构**
   - 移除所有冗余文件
   - 按分类组织图片
   - 优化存储空间

4. **可重用的自动化工具**
   - 支持多平台游戏采集
   - 智能截图和图片处理
   - 批量处理和错误恢复

5. **详细的处理报告**
   - 成功率统计
   - 错误问题记录
   - 改进建议

---

## 🔧 使用指南

### 快速开始

```bash
# 1. 安装依赖
npm install

# 2. 备份现有数据
npm run backup-data

# 3. 清理文件结构
npm run clean-files

# 4. 运行自动化采集
npm run scrape-games

# 5. 验证数据质量
npm run validate-data
```

### 配置游戏列表

在 `scripts/game-list.json` 中配置要采集的游戏：

```json
[
  {
    "url": "https://www.crazygames.com/embed/2048",
    "category": "math",
    "title": "2048"
  },
  {
    "url": "https://www.miniplay.com/embed/math-duck", 
    "category": "math",
    "title": "Math Duck"
  }
]
```

### 自定义采集规则

可以在 `scripts/game-scraper.js` 中自定义：

- 平台特定的数据提取规则
- 截图策略和参数
- 图片处理质量设置
- 错误处理和重试逻辑

---

## 🎯 总结

通过这个自动化采集系统，我们可以：

1. **大幅提高效率** - 85%的工作自动化完成
2. **确保数据质量** - 统一的格式和验证标准
3. **优化文件结构** - 清理冗余，按分类组织
4. **支持批量处理** - 一次性处理大量游戏
5. **便于维护扩展** - 模块化设计，易于添加新平台

这个系统将帮助你快速、高质量地完成游戏数据的录入和管理工作，为EduGameHQ平台提供丰富、准确的游戏资源。

---

**文档版本**: v1.0  
**创建日期**: 2024年12月  
**适用项目**: EduGameHQ.com  
**技术栈**: Astro 5.0 + React 19 + TypeScript 